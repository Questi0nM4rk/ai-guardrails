"""Tests for guardrails.hooks.protect_configs -- Claude Code PreToolUse config protector."""

from __future__ import annotations

import json
from pathlib import Path
from typing import TYPE_CHECKING
from unittest.mock import patch

from guardrails.constants import REGISTRY_FILENAME
from guardrails.hooks.protect_configs import _emit_ask, main

if TYPE_CHECKING:
    import pytest


class TestEmitAsk:
    """Test the _emit_ask helper."""

    def test_outputs_valid_json(self, capsys: pytest.CaptureFixture[str]) -> None:
        _emit_ask("some reason")
        captured = capsys.readouterr()
        data = json.loads(captured.out)
        assert data["hookSpecificOutput"]["permissionDecision"] == "ask"
        assert data["hookSpecificOutput"]["permissionDecisionReason"] == "some reason"
        assert data["hookSpecificOutput"]["hookEventName"] == "PreToolUse"

    def test_returns_0(self) -> None:
        assert _emit_ask("reason") == 0


class TestMainNoRegistry:
    """Test main() when no .guardrails-exceptions.toml exists."""

    def test_returns_0_without_registry(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        monkeypatch.chdir(tmp_path)
        stdin_data = json.dumps({"tool_input": {"file_path": "ruff.toml"}})
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            assert main() == 0


class TestMainAutoGenerated:
    """Test Check 1: auto-generated config files."""

    def test_asks_for_autogenerated_config(
        self,
        tmp_path: Path,
        monkeypatch: pytest.MonkeyPatch,
        capsys: pytest.CaptureFixture[str],
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")
        config_file = tmp_path / "ruff.toml"
        config_file.write_text("# AUTO-GENERATED by ai-guardrails\n[lint]\n")

        stdin_data = json.dumps({"tool_input": {"file_path": str(config_file)}})
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            result = main()

        assert result == 0
        captured = capsys.readouterr()
        data = json.loads(captured.out)
        assert data["hookSpecificOutput"]["permissionDecision"] == "ask"
        assert "auto-generated" in data["hookSpecificOutput"]["permissionDecisionReason"].lower()

    def test_allows_non_autogenerated_config(
        self,
        tmp_path: Path,
        monkeypatch: pytest.MonkeyPatch,
        capsys: pytest.CaptureFixture[str],
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")
        config_file = tmp_path / "ruff.toml"
        config_file.write_text("[lint]\nselect = ['E']\n")

        stdin_data = json.dumps({"tool_input": {"file_path": str(config_file)}})
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            result = main()

        assert result == 0
        captured = capsys.readouterr()
        assert captured.out == ""


class TestMainExceptionsToml:
    """Test Check 2: editing .guardrails-exceptions.toml itself."""

    def test_asks_for_registry_edit(
        self,
        tmp_path: Path,
        monkeypatch: pytest.MonkeyPatch,
        capsys: pytest.CaptureFixture[str],
    ) -> None:
        monkeypatch.chdir(tmp_path)
        registry = tmp_path / REGISTRY_FILENAME
        registry.write_text("schema_version = 1\n")

        stdin_data = json.dumps({"tool_input": {"file_path": str(registry)}})
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            result = main()

        assert result == 0
        captured = capsys.readouterr()
        data = json.loads(captured.out)
        assert data["hookSpecificOutput"]["permissionDecision"] == "ask"
        assert "source of truth" in data["hookSpecificOutput"]["permissionDecisionReason"].lower()


class TestMainIgnorePatterns:
    """Test Check 3: ignore patterns in config files."""

    def test_asks_when_ignore_pattern_in_new_content(
        self,
        tmp_path: Path,
        monkeypatch: pytest.MonkeyPatch,
        capsys: pytest.CaptureFixture[str],
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")

        stdin_data = json.dumps(
            {
                "tool_input": {
                    "file_path": "pyproject.toml",
                    "new_string": 'ignore = ["E501"]',
                }
            }
        )
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            result = main()

        assert result == 0
        captured = capsys.readouterr()
        data = json.loads(captured.out)
        assert data["hookSpecificOutput"]["permissionDecision"] == "ask"
        assert "Ignore pattern" in data["hookSpecificOutput"]["permissionDecisionReason"]

    def test_asks_when_noqa_in_content(
        self,
        tmp_path: Path,
        monkeypatch: pytest.MonkeyPatch,
        capsys: pytest.CaptureFixture[str],
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")

        stdin_data = json.dumps(
            {
                "tool_input": {
                    "file_path": "pyproject.toml",
                    "content": "noqa = true",
                }
            }
        )
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            result = main()

        assert result == 0
        captured = capsys.readouterr()
        data = json.loads(captured.out)
        assert data["hookSpecificOutput"]["permissionDecision"] == "ask"

    def test_allows_normal_config_edit(
        self,
        tmp_path: Path,
        monkeypatch: pytest.MonkeyPatch,
        capsys: pytest.CaptureFixture[str],
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")

        stdin_data = json.dumps(
            {
                "tool_input": {
                    "file_path": "pyproject.toml",
                    "new_string": "line-length = 100",
                }
            }
        )
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            result = main()

        assert result == 0
        captured = capsys.readouterr()
        assert captured.out == ""


class TestMainEdgeCases:
    """Test edge cases in main()."""

    def test_returns_0_on_invalid_json(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = "not json"
            assert main() == 0

    def test_returns_0_on_empty_file_path(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")
        stdin_data = json.dumps({"tool_input": {"file_path": ""}})
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            assert main() == 0

    def test_returns_0_for_non_config_file(
        self,
        tmp_path: Path,
        monkeypatch: pytest.MonkeyPatch,
        capsys: pytest.CaptureFixture[str],
    ) -> None:
        monkeypatch.chdir(tmp_path)
        (tmp_path / REGISTRY_FILENAME).write_text("schema_version = 1\n")
        stdin_data = json.dumps({"tool_input": {"file_path": "src/main.py"}})
        with patch("sys.stdin") as mock_stdin:
            mock_stdin.read.return_value = stdin_data
            result = main()

        assert result == 0
        captured = capsys.readouterr()
        assert captured.out == ""
