# CodeRabbit Configuration
# https://docs.coderabbit.ai/reference/configuration

language: en-US

reviews:
  # Assertive = thorough, detailed feedback (matches our pedantic philosophy)
  profile: "assertive"

  # Submit "Request Changes" when actionable comments exist
  # Submit "Approved" when all comments are resolved
  request_changes_workflow: true

  # Review output
  high_level_summary: true
  poem: false
  review_status: true
  collapse_walkthrough: false

  # Manual review only — do NOT auto-review every push.
  # Free tier allows only 3 reviews/hour. Auto-reviewing wastes them on
  # WIP pushes that aren't ready for review.
  #
  # Workflow:
  #   1. Push changes, let CI + Claude + DeepSource + Gemini run
  #   2. Resolve ALL their comments first
  #   3. Only then trigger: @coderabbitai review
  #   4. For a full re-review: @coderabbitai full review
  auto_review:
    enabled: false
    drafts: false
    auto_incremental_review: true

  # Stop review if PR is closed/merged
  abort_on_close: true

  # Path-specific review instructions
  path_instructions:
    # Global rules — applied to ALL files
    # CodeRabbit's specialization: static analysis, security, language conventions.
    # Claude handles: code duplication, architecture, design patterns.
    # Gemini handles: bugs, logic errors, performance.
    - path: "**/*"
      instructions: |
        Your specialization — focus on these:
        - Static analysis: flag issues caught by linters (ruff, shellcheck, etc.)
        - Security: secrets, injection, unsafe operations (via gitleaks, semgrep)
        - Dependency vulnerabilities (via osv-scanner)
        - Language conventions: enforce per-language best practices
        - Flag code that bypasses pre-commit hooks
    - path: "**/*.py"
      instructions: |
        - Enforce type hints on all function signatures
        - Check for proper exception handling (no bare except)
        - Verify docstrings on public functions/classes
        - Enforce modern Python: f-strings over .format(), pathlib over os.path, walrus operator where cleaner
    - path: "**/*.sh"
      instructions: |
        - Verify scripts use set -euo pipefail
        - Check for proper quoting of variables
        - Ensure portable syntax (POSIX where possible, or document bash-isms)
    - path: "**/tests/**"
      instructions: |
        - Focus on test coverage and edge cases
        - Verify meaningful assertions

  # Static analysis tools — all enabled for maximum coverage
  tools:
    # Python
    ruff:
      enabled: true
    # Shell
    shellcheck:
      enabled: true
    # Markdown
    markdownlint:
      enabled: true
    # YAML
    yamllint:
      enabled: true
    # Security — secret detection
    gitleaks:
      enabled: true
    # Security — SAST
    semgrep:
      enabled: true
    # Security — dependency vulnerabilities
    osvScanner:
      enabled: true
    # Security — IaC scanning
    checkov:
      enabled: true
    # Spell/grammar checking
    languagetool:
      enabled: true
    # GitHub Actions workflow validation
    actionlint:
      enabled: true
    # Dockerfile best practices
    hadolint:
      enabled: true

  # AI-generated additions
  finishing_touches:
    docstrings:
      enabled: true
    unit_tests:
      enabled: true

chat:
  auto_reply: true
