"""Universal PR review comments â€” list, reply, and resolve threads from all bots.

Supports CodeRabbit and Claude review threads.
Uses GitHub GraphQL API for fetching/resolving threads and REST API for replies.

Usage::

    ai-guardrails comments --pr 31
    ai-guardrails comments --pr 31 --bot claude
    ai-guardrails comments --pr 31 --reply PRRT_abc "Fixed."
    ai-guardrails comments --pr 31 --resolve PRRT_abc "Fixed."
    ai-guardrails comments --pr 31 --resolve-all --bot coderabbit
    ai-guardrails comments --pr 31 --json
"""

from __future__ import annotations

import json
import re
import subprocess
import sys
from collections import Counter

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

COMPACT_PREVIEW_LENGTH = 80
JSON_PREVIEW_LENGTH = 120
_SUBPROCESS_TIMEOUT = 30
_MAX_PAGES = 20
_MIN_BOT_COL = 8
_MIN_LOC_COL = 10

# Valid category prefixes for resolve messages.
# Each resolve reply must start with one of these.
VALID_RESOLVE_CATEGORIES: tuple[str, ...] = (
    "Fixed in",
    "False positive:",
    "Won't fix:",
)

BOT_ALIASES: dict[str, str] = {
    "coderabbit": "coderabbitai",
    "claude": "claude",
    "pr-agent": "pr-agent",
}

# PR-Agent markers found in comment bodies (posted as github-actions[bot])
_PR_AGENT_MARKERS = ("pr-agent", "qodo", "/review", "/improve")


def _detect_pr_agent(body: str) -> bool:
    """Check if a comment body was generated by PR-Agent."""
    lower = body.lower()
    return any(marker in lower for marker in _PR_AGENT_MARKERS)


# Reverse mapping: full login -> short alias (for compact display)
_LOGIN_TO_ALIAS: dict[str, str] = {v: k for k, v in BOT_ALIASES.items()}

GRAPHQL_THREADS_QUERY = """
query($owner: String!, $repo: String!, $pr: Int!, $cursor: String) {
  repository(owner: $owner, name: $repo) {
    pullRequest(number: $pr) {
      reviewThreads(first: 100, after: $cursor) {
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          id
          isResolved
          comments(first: 5) {
            totalCount
            nodes {
              id
              databaseId
              author { login }
              body
              path
              line
              startLine
              createdAt
            }
          }
        }
      }
    }
  }
}
"""

GRAPHQL_JQ_FILTER = ".data.repository.pullRequest.reviewThreads"

RESOLVE_MUTATION = """
mutation($threadId: ID!) {
  resolveReviewThread(input: {threadId: $threadId}) {
    thread { isResolved }
  }
}
"""


# ---------------------------------------------------------------------------
# Resolve message validation
# ---------------------------------------------------------------------------


def validate_resolve_message(message: str | None) -> bool:
    """Check that a resolve message starts with a valid category prefix.

    Valid prefixes (case-insensitive):
    - ``Fixed in <commit-hash>``
    - ``False positive: <reason>``
    - ``Won't fix: <reason>`` (straight or curly apostrophe)

    The message must also contain content after the prefix (e.g. a commit hash
    or an explanation).

    Returns True if valid, False otherwise.
    """
    if message is None:
        return False

    stripped = message.strip()
    if not stripped:
        return False

    lower = stripped.lower()
    # Normalize curly apostrophe to straight
    lower = lower.replace("\u2019", "'")

    for category in VALID_RESOLVE_CATEGORIES:
        cat_lower = category.lower()
        if lower.startswith(cat_lower):
            # Must have content after the prefix
            rest = stripped[len(cat_lower) :].strip()
            return len(rest) > 0
    return False


# ---------------------------------------------------------------------------
# Subprocess helper
# ---------------------------------------------------------------------------


def _run_gh(*args: str) -> subprocess.CompletedProcess[str]:
    """Run a ``gh`` CLI command with timeout.

    Returns a CompletedProcess with returncode=1 on timeout.
    """
    try:
        return subprocess.run(
            ["gh", *args],
            capture_output=True,
            text=True,
            check=False,
            timeout=_SUBPROCESS_TIMEOUT,
        )
    except subprocess.TimeoutExpired:
        return subprocess.CompletedProcess(
            args=["gh", *args],
            returncode=1,
            stdout="",
            stderr=f"Timeout after {_SUBPROCESS_TIMEOUT}s",
        )


# ---------------------------------------------------------------------------
# Thread parsing
# ---------------------------------------------------------------------------


def _clean_body(body: str) -> str:
    """Strip HTML tags and collapse whitespace for preview."""
    text = re.sub(r"</?[a-zA-Z][^>]*>", "", body)
    text = re.sub(r"\n+", " ", text)
    return re.sub(r"\s+", " ", text).strip()


def _truncate(text: str, length: int) -> str:
    """Truncate text to length with ellipsis."""
    if len(text) <= length:
        return text
    ellipsis_room = 3
    if length <= ellipsis_room:
        return text[:length]
    return text[: length - ellipsis_room] + "..."


def _short_bot_name(login: str) -> str:
    """Convert full bot login to short alias for display."""
    return _LOGIN_TO_ALIAS.get(login, login)


def parse_thread(node: dict) -> dict | None:
    """Parse a GraphQL reviewThread node into a flat dict.

    Returns None if the thread has no comments.
    """
    comments = node.get("comments", {}).get("nodes", [])
    if not comments:
        return None

    first = comments[0]
    author = (first.get("author") or {}).get("login", "unknown")
    raw_body = first.get("body", "")
    bot = author.removesuffix("[bot]").lower()

    # Content-based detection: github-actions posts from many Actions,
    # so check body for PR-Agent markers to disambiguate.
    if bot == "github-actions" and _detect_pr_agent(raw_body):
        bot = "pr-agent"

    return {
        "thread_id": node.get("id", ""),
        "comment_id": first.get("databaseId"),
        "bot": bot,
        "path": first.get("path", ""),
        "line": first.get("line"),
        "start_line": first.get("startLine"),
        "resolved": node.get("isResolved", False),
        "body_preview": _clean_body(raw_body),
        "created_at": first.get("createdAt", ""),
        "reply_count": node.get("comments", {}).get("totalCount", 1) - 1,
    }


def _resolve_bot_name(name: str) -> str:
    """Resolve a bot alias or full name to the GitHub login."""
    lower = name.lower().removesuffix("[bot]")
    if lower in BOT_ALIASES:
        return BOT_ALIASES[lower]
    # Check if it's already a full login
    for login in BOT_ALIASES.values():
        if lower == login.lower():
            return login
    return lower


# ---------------------------------------------------------------------------
# Filtering
# ---------------------------------------------------------------------------


def filter_threads(
    threads: list[dict],
    *,
    bots: list[str] | None = None,
    unresolved_only: bool = True,
) -> list[dict]:
    """Filter threads by bot name and resolution status."""
    result = threads

    if unresolved_only:
        result = [t for t in result if not t["resolved"]]

    if bots:
        resolved_names = {_resolve_bot_name(b) for b in bots}
        result = [t for t in result if t["bot"] in resolved_names]

    return result


def _find_thread(threads: list[dict], thread_id: str) -> dict | None:
    """Find a thread by ID, printing an error if not found."""
    target = next((t for t in threads if t["thread_id"] == thread_id), None)
    if target is None:
        print(f"Error: Thread {thread_id} not found", file=sys.stderr)
    return target


# ---------------------------------------------------------------------------
# Output formatting
# ---------------------------------------------------------------------------


def _build_summary(threads: list[dict]) -> dict:
    """Build summary statistics from thread list."""
    by_bot = Counter(t["bot"] for t in threads)
    unresolved = sum(1 for t in threads if not t["resolved"])
    return {
        "total": len(threads),
        "unresolved": unresolved,
        "by_bot": dict(sorted(by_bot.items())),
    }


def _thread_location(thread: dict) -> str:
    """Build ``file:line`` location string for a thread."""
    path = thread["path"].rsplit("/", 1)[-1] if thread["path"] else "?"
    if thread["line"]:
        return f"{path}:{thread['line']}"
    return path


def format_compact(threads: list[dict]) -> str:
    """Format threads as compact one-line-per-thread output.

    Example::

        # 60 unresolved | claude: 11, deepsource: 43, gemini: 5, coderabbit: 1

        PRRT_kwDO...eFH  deepsource  core.py:48       line too long (99 > 88 characters)
        PRRT_kwDO...qNJ  claude      python.py:20     Code duplication: This _fail_no_uv...
    """
    summary = _build_summary(threads)
    bot_counts = ", ".join(
        f"{_short_bot_name(bot)}: {count}" for bot, count in summary["by_bot"].items()
    )

    lines = [f"# {summary['unresolved']} unresolved | {bot_counts}", ""]

    # Compute column widths from data
    bot_width = (
        max(_MIN_BOT_COL, *(len(_short_bot_name(t["bot"])) for t in threads))
        if threads
        else _MIN_BOT_COL
    )
    loc_width = (
        max(_MIN_LOC_COL, *(len(_thread_location(t)) for t in threads)) if threads else _MIN_LOC_COL
    )

    for t in threads:
        tid = t["thread_id"]
        bot = _short_bot_name(t["bot"])
        loc = _thread_location(t)
        preview = _truncate(t["body_preview"], COMPACT_PREVIEW_LENGTH)
        resolved = " [resolved]" if t["resolved"] else ""

        lines.append(f"{tid}  {bot:<{bot_width}s} {loc:<{loc_width}s} {preview}{resolved}")

    return "\n".join(lines)


def format_json(threads: list[dict], *, pretty: bool = False) -> str:
    """Format threads as JSON with summary statistics."""
    summary = _build_summary(threads)

    # Truncate body previews for JSON output
    json_threads = []
    for t in threads:
        t_copy = dict(t)
        t_copy["body_preview"] = _truncate(t["body_preview"], JSON_PREVIEW_LENGTH)
        json_threads.append(t_copy)

    output = {"threads": json_threads, "summary": summary}
    indent = 2 if pretty else None
    return json.dumps(output, indent=indent)


# ---------------------------------------------------------------------------
# GitHub API interactions
# ---------------------------------------------------------------------------


def _get_pr_number() -> int | None:
    """Get PR number from current branch via gh CLI."""
    result = _run_gh("pr", "view", "--json", "number", "--jq", ".number")
    if result.returncode != 0 or not result.stdout.strip():
        return None
    try:
        return int(result.stdout.strip())
    except ValueError:
        return None


def _get_repo_info() -> tuple[str, str] | None:
    """Get (owner, repo) from current git context via gh CLI."""
    result = _run_gh(
        "repo",
        "view",
        "--json",
        "owner,name",
        "--jq",
        r'"\(.owner.login) \(.name)"',
    )
    if result.returncode != 0:
        return None
    parts = result.stdout.strip().split()
    expected_parts = 2
    if len(parts) != expected_parts:
        return None
    return (parts[0], parts[1])


def fetch_threads(owner: str, repo: str, pr: int) -> list[dict]:
    """Fetch all review threads via GraphQL with cursor-based pagination.

    Returns parsed thread dicts (not filtered by bot or resolution status).
    """
    all_threads: list[dict] = []
    cursor: str | None = None

    for _page in range(_MAX_PAGES):
        cmd: list[str] = [
            "api",
            "graphql",
            "-f",
            f"query={GRAPHQL_THREADS_QUERY}",
            "-f",
            f"owner={owner}",
            "-f",
            f"repo={repo}",
            "-F",
            f"pr={pr}",
            "--jq",
            GRAPHQL_JQ_FILTER,
        ]
        if cursor:
            cmd.extend(["-f", f"cursor={cursor}"])

        result = _run_gh(*cmd)
        if result.returncode != 0:
            print("Warning: Failed to fetch review threads via GraphQL", file=sys.stderr)
            break

        try:
            data = json.loads(result.stdout.strip())
        except json.JSONDecodeError:
            print("Warning: Invalid JSON from GraphQL response", file=sys.stderr)
            break

        nodes = data.get("nodes", [])
        for node in nodes:
            parsed = parse_thread(node)
            if parsed:
                all_threads.append(parsed)

        page_info = data.get("pageInfo", {})
        if not page_info.get("hasNextPage"):
            break
        cursor = page_info.get("endCursor")

    return all_threads


def reply_to_thread(owner: str, repo: str, pr: int, comment_id: int, body: str) -> bool:
    """Reply to a review comment via REST API.

    Returns True on success, False on failure.
    """
    result = _run_gh(
        "api",
        f"repos/{owner}/{repo}/pulls/{pr}/comments/{comment_id}/replies",
        "-f",
        f"body={body}",
    )
    if result.returncode != 0:
        print(f"Error: Failed to reply to comment {comment_id}", file=sys.stderr)
        return False
    return True


def resolve_thread(thread_id: str) -> bool:
    """Resolve a review thread via GraphQL mutation.

    Returns True on success, False on failure.
    """
    result = _run_gh(
        "api",
        "graphql",
        "-f",
        f"query={RESOLVE_MUTATION}",
        "-f",
        f"threadId={thread_id}",
    )
    if result.returncode != 0:
        print(f"Error: Failed to resolve thread {thread_id}", file=sys.stderr)
        return False
    return True


def resolve_threads(
    owner: str,
    repo: str,
    pr: int,
    threads: list[dict],
    *,
    reply_body: str | None = None,
) -> tuple[int, int]:
    """Resolve multiple threads, optionally replying first.

    Expects pre-filtered unresolved threads (see :func:`filter_threads`).
    Returns (resolved_count, failed_count).
    """
    resolved = 0
    failed = 0
    for thread in threads:
        if reply_body:
            if thread["comment_id"]:
                if not reply_to_thread(owner, repo, pr, thread["comment_id"], reply_body):
                    failed += 1
                    continue
            else:
                print(
                    f"Warning: Thread {thread['thread_id']} has no comment ID, reply skipped",
                    file=sys.stderr,
                )

        if resolve_thread(thread["thread_id"]):
            resolved += 1
        else:
            failed += 1

    return resolved, failed


# ---------------------------------------------------------------------------
# Main entry point
# ---------------------------------------------------------------------------


def run_comments(
    *,
    pr: int | None = None,
    bot: str | None = None,
    reply: tuple[str, str] | None = None,
    resolve: tuple[str, str | None] | None = None,
    resolve_all: bool = False,
    resolve_all_body: str | None = None,
    show_all: bool = False,
    output_json: bool = False,
) -> int:
    """Main entry point for the ``comments`` subcommand.

    Args:
        pr: PR number (default: current branch's PR).
        bot: Comma-separated bot filter (e.g. "coderabbit,claude").
        reply: (thread_id, body) tuple for replying to a thread.
        resolve: (thread_id, optional_body) tuple for resolving a thread.
        resolve_all: Resolve all unresolved threads (filtered by --bot).
        resolve_all_body: Optional reply body when batch-resolving.
        show_all: Show resolved threads too.
        output_json: Output full JSON instead of compact format.

    Returns:
        Exit code (0 success, 1 error).

    """
    # Get PR number
    if pr is None:
        pr = _get_pr_number()
        if pr is None:
            print("Error: No PR found for current branch. Use --pr NUMBER", file=sys.stderr)
            return 1

    # Get repo info
    repo_info = _get_repo_info()
    if repo_info is None:
        print("Error: Could not determine repository info", file=sys.stderr)
        return 1
    owner, repo = repo_info

    # Parse bot filter (strip empty entries from e.g. "claude,,deepsource")
    bot_list = [b.strip() for b in bot.split(",") if b.strip()] if bot else None

    # Fetch all threads
    all_threads = fetch_threads(owner, repo, pr)

    # Handle reply action
    if reply is not None:
        thread_id, body = reply
        target = _find_thread(all_threads, thread_id)
        if target is None:
            return 1
        if target["comment_id"] is None:
            print("Error: Thread has no comment ID for reply", file=sys.stderr)
            return 1
        ok = reply_to_thread(owner, repo, pr, target["comment_id"], body)
        return 0 if ok else 1

    # Handle resolve action
    if resolve is not None:
        thread_id, body = resolve
        if not validate_resolve_message(body):
            cats = ", ".join(VALID_RESOLVE_CATEGORIES)
            print(
                f"Error: Resolve message requires a valid category prefix: {cats}\n"
                "See 'Review Thread Resolution Protocol' in CLAUDE.md.",
                file=sys.stderr,
            )
            return 1
        target = _find_thread(all_threads, thread_id)
        if target is None:
            return 1
        if body:
            if target["comment_id"]:
                if not reply_to_thread(owner, repo, pr, target["comment_id"], body):
                    return 1
            else:
                print(
                    "Warning: Thread has no comment ID, reply skipped",
                    file=sys.stderr,
                )
        ok = resolve_thread(thread_id)
        return 0 if ok else 1

    # Handle resolve-all action
    if resolve_all:
        if resolve_all_body is not None and not validate_resolve_message(resolve_all_body):
            cats = ", ".join(VALID_RESOLVE_CATEGORIES)
            print(
                f"Error: Resolve message requires a valid category prefix: {cats}\n"
                "See 'Review Thread Resolution Protocol' in CLAUDE.md.",
                file=sys.stderr,
            )
            return 1
        filtered = filter_threads(all_threads, bots=bot_list, unresolved_only=True)
        if not filtered:
            print("No unresolved threads to resolve", file=sys.stderr)
            return 0
        resolved, failed = resolve_threads(
            owner,
            repo,
            pr,
            filtered,
            reply_body=resolve_all_body,
        )
        print(f"Resolved {resolved} thread(s), {failed} failed", file=sys.stderr)
        return 0 if failed == 0 else 1

    # Default: list threads
    filtered = filter_threads(all_threads, bots=bot_list, unresolved_only=not show_all)
    if output_json:
        print(format_json(filtered, pretty=True))
    else:
        print(format_compact(filtered))
    return 0
